var documenterSearchIndex = {"docs":
[{"location":"#MomentDistances","page":"MomentDistances","title":"MomentDistances","text":"","category":"section"},{"location":"#MomentDistances","page":"MomentDistances","title":"MomentDistances","text":"MomentDistances.jl\n\n(Image: Lifecycle) (Image: CI) (Image: codecov.io)\n\nThis is a Julia package to help define distance metrics, primarily for indirect inference. Most of the functionality is trivial, in the sense that one could just as easily code it up in a few lines, but the advantage of having it in a package is that it can be documented and tested.\n\nI use it in my own work, won't be registered until the API stabilizes.\n\n\n\n\n\n","category":"module"},{"location":"#Generic-interface","page":"MomentDistances","title":"Generic interface","text":"","category":"section"},{"location":"","page":"MomentDistances","title":"MomentDistances","text":"Distances are always calculated between two arguments, conventionally named data and model. Generally, they would contain collections of the same moments calculated from the data, and simulated from a model (with given parameters).","category":"page"},{"location":"#MomentDistances.distance","page":"MomentDistances","title":"MomentDistances.distance","text":"distance(metric, data, model)\n\nCalculate the distance (a real number) between data and model using metric.\n\nImportantly, distance is not a metric in the mathematical sense, for example, it can be asymmetric.\n\nDistances are always finite. In practice, this means that they throw a DomainError for non-finite arguments.\n\nHowever, it is guaranteed that distance(metric, x, x) is zero for all possible metric and x values.\n\n\n\n\n\n","category":"function"},{"location":"#Defining-metrics","page":"MomentDistances","title":"Defining metrics","text":"","category":"section"},{"location":"","page":"MomentDistances","title":"MomentDistances","text":"Generally, one would define metric as transformations of primitives, organized into named tuples. An example would be","category":"page"},{"location":"","page":"MomentDistances","title":"MomentDistances","text":"using MomentDistances\nmetric = NamedPNorm(a = RelDiff(), b = 0.3 * AbsDiff())","category":"page"},{"location":"","page":"MomentDistances","title":"MomentDistances","text":"which ","category":"page"},{"location":"","page":"MomentDistances","title":"MomentDistances","text":"takes named tuples,\ncompares their a elements using RelDiff,\ncompares their b elements using AbsDiff, multiplying it with the given weight.","category":"page"},{"location":"#Primitives","page":"MomentDistances","title":"Primitives","text":"","category":"section"},{"location":"","page":"MomentDistances","title":"MomentDistances","text":"Distance metrics are built up from primitives, defined on scalars.","category":"page"},{"location":"#MomentDistances.AbsDiff","page":"MomentDistances","title":"MomentDistances.AbsDiff","text":"AbsDiff()\n\n\nAbsolute difference between the arguments.\n\njulia> distance(AbsDiff(), 0.3, 0.6)\n0.3\n\n\n\n\n\n","category":"type"},{"location":"#MomentDistances.RelDiff","page":"MomentDistances","title":"MomentDistances.RelDiff","text":"RelDiff()\n\n\nRelative difference between data and model, calculated as abs(data - model) / abs(data).\n\nIf data == 0, an error is thrown.\n\njulia> distance(RelDiff(), 0.2, 0.23)\n0.15\n\n\n\n\n\n","category":"type"},{"location":"#Weights","page":"MomentDistances","title":"Weights","text":"","category":"section"},{"location":"#MomentDistances.Weighted","page":"MomentDistances","title":"MomentDistances.Weighted","text":"Weighted(parent, weight)\n\n\nMultiply the distance by a positive weight.\n\njulia> distance(AbsDiff(), 0.1, 0.2)\n0.1\n\njulia> distance(Weighted(AbsDiff(), 10), 0.1, 0.2)\n1.0\n\nNote that you can also create weighted metric using weight * metric.\n\n\n\n\n\n","category":"type"},{"location":"#Aggregation","page":"MomentDistances","title":"Aggregation","text":"","category":"section"},{"location":"#MomentDistances.PNorm","page":"MomentDistances","title":"MomentDistances.PNorm","text":"PNorm(elementwise_metric)\nPNorm(elementwise_metric, p)\n\n\nApply the elementwise metric, then calculate a p-norm.\n\n\n\n\n\n","category":"type"},{"location":"#MomentDistances.NamedPNorm","page":"MomentDistances","title":"MomentDistances.NamedPNorm","text":"NamedPNorm(named_metrics)\nNamedPNorm(named_metrics, p)\n\n\nApply the metrics in the given NamedTuple to data and moment, which should support getproperty.\n\nThe default p for p-norms is 2 (Euclidean norm).\n\nNote that extra properties in the arguments are ignored.\n\njulia> metric = NamedPNorm((a = RelDiff(), b = AbsDiff()))\nNamedPNorm((a = RelDiff(), b = AbsDiff()))\n\njulia> distance(metric, (a = 1, b = 2), (a = 3, b = 4)) # ≈ √8\n2.8284271247461903\n\njulia> distance(metric,\n       (a = 1, b = 2, c = \"a fish\"),     # c ignored, not in metric\n       (a = 3, b = 4, d = \"an octopus\")) # d ignored, not in metric\n2.8284271247461903\n\n\n\n\n\nNamedPNorm(; ...)\nNamedPNorm(p; kw...)\n\n\nAlternative convenience constructor using keyword arguments.\n\njulia> NamedPNorm(a = RelDiff(), b = AbsDiff())\nNamedPNorm((a = RelDiff(), b = AbsDiff()))\n\nThe default p for p-norms is 2 (Euclidean norm).\n\n\n\n\n\n","category":"type"}]
}
